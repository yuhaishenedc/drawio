<mxfile host="app.diagrams.net" modified="2024-02-09T04:08:32.317Z" agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36 Edg/121.0.0.0" etag="wukHV-44JD1Ef7hfKiod" version="23.1.2" type="github">
  <diagram name="第 1 页" id="U_HhLAPaVu63GRcEfQPl">
    <mxGraphModel dx="2681" dy="3330" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="591SITI4Ghsz0lOfu50e-1" value="&lt;div&gt;class WebThreadImpl : public blink::WebThread {&lt;/div&gt;&lt;div&gt;public:&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; explicit WebThreadImpl(const char* name);&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; virtual ~WebThreadImpl();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; static const int kDefaultPriority = 100;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; static const int kLoadingPriority = 200;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; virtual void postTask(const blink::WebTraceLocation&amp;amp;, blink::WebThread::Task*) override;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; virtual void postDelayedTask(const blink::WebTraceLocation&amp;amp;, blink::WebThread::Task*, long long delayMs) override;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void postDelayedTaskWithPriorityCrossThread(const blink::WebTraceLocation&amp;amp; location,&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; blink::WebThread::Task* task,&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; long long delayMs,&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; int priority);&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; virtual bool isCurrentThread() const override;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; virtual blink::PlatformThreadId threadId() const override;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; virtual void addTaskObserver(TaskObserver*) override;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; virtual void removeTaskObserver(TaskObserver*) override;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; // Returns the scheduler associated with the thread.&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; virtual blink::WebScheduler* scheduler() const override;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void willExit();&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void startTriggerTasks();&amp;nbsp; //遍历m_taskPairsToPost对象，调用postDelayedTaskImpl方法&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void schedulerTasks();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; bool hasImmediatelyTimer();&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void fire();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void suspendTimerQueue();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void resumeTimerQueue();&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void cancelTimerTask(WebThread::Task* task);&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void disableScheduler();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void enableScheduler();&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; std::vector&amp;lt;WebTimerBase*&amp;gt;&amp;amp; timerHeap();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void updateSharedTimer();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void appendUnusedTimerToDelete(WebTimerBase* timer) { m_unusedTimersToDelete.push_back(timer); }&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; bool threadClosed() { return m_threadClosed; }&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void shutdown();&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; static unsigned getNewCurrentHeapInsertionOrder();&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;private:&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void fireOnExit();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void waitForExit();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void fireTimeOnExit();&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; struct TaskPair {&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; TaskPair(const blink::WebTraceLocation&amp;amp; location, blink::WebThread::Task* task, long long delayMs, int priority);&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; static void sortByPriority(std::vector&amp;lt;TaskPair*&amp;gt;*);&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; blink::WebTraceLocation location;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; blink::WebThread::Task* task;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; long long delayMs;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; int priority;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; double createTime;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; unsigned heapInsertionOrder;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; };&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void postDelayedTaskImpl(&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; const blink::WebTraceLocation&amp;amp; location, blink::WebThread::Task* task, long long delayMs, double* createTimeOnOtherThread, int priority, unsigned* heapInsertionOrder);&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; static DWORD __stdcall WebThreadImplThreadEntryPoint(void* param);&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void threadEntryPoint();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void deleteUnusedTimers();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void deleteTimersOnExit();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void deleteTaskPairsToPostOnExit();&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void willProcessTasks();&amp;nbsp; //遍历m_observers容器中的对象，并调用其willProcessTask方法&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void didProcessTasks();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void clearEmptyObservers();&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; HANDLE m_hEvent;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; blink::PlatformThreadId m_threadId;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; bool m_willExit;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; bool m_threadClosed;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; int m_firingTimers; // Reentrancy guard.&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; WebSchedulerImpl* m_webSchedulerImpl;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; // 不能用wtf的函数，否则退出后wtf被关闭了，就不能访问了&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; std::vector&amp;lt;WebTimerBase*&amp;gt; m_timerHeap;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; std::vector&amp;lt;WebTimerBase*&amp;gt; m_unusedTimersToDelete;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; std::vector&amp;lt;TaskPair*&amp;gt; m_taskPairsToPost;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; std::vector&amp;lt;TaskObserver*&amp;gt; m_observers;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; bool m_isObserversDirty;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; const char* m_name;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; CRITICAL_SECTION m_taskPairsMutex;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; CRITICAL_SECTION m_observersMutex;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; bool m_suspendTimerQueue;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; bool m_hadThreadInit;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; HANDLE m_threadHandle;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; double m_currentFrameCreateTime; // 当前帧全部使用这个创建时间&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; static unsigned m_currentHeapInsertionOrder;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; bool m_isMainThread;&lt;/div&gt;&lt;div&gt;};&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;align=left;" vertex="1" parent="1">
          <mxGeometry x="290" y="-1340" width="1080" height="1590" as="geometry" />
        </mxCell>
        <mxCell id="591SITI4Ghsz0lOfu50e-2" value="schedulerTasks" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="120" y="-940" width="100" height="40" as="geometry" />
        </mxCell>
        <mxCell id="591SITI4Ghsz0lOfu50e-3" value="" style="endArrow=none;html=1;rounded=0;entryX=0.002;entryY=0.264;entryDx=0;entryDy=0;entryPerimeter=0;" edge="1" parent="1" target="591SITI4Ghsz0lOfu50e-1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="220" y="-920" as="sourcePoint" />
            <mxPoint x="270" y="-970" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="591SITI4Ghsz0lOfu50e-4" value="&lt;div&gt;class WebTimerBase {&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; WTF_MAKE_NONCOPYABLE(WebTimerBase); WTF_MAKE_FAST_ALLOCATED(WebTimerBase);&lt;/div&gt;&lt;div&gt;public:&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; static WebTimerBase* create(WebThreadImpl* threadTimers, const blink::WebTraceLocation&amp;amp; location, blink::WebThread::Task* task, int priority)&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; {&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return new WebTimerBase(threadTimers, location, task, priority);&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; }&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; ~WebTimerBase();&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; std::vector&amp;lt;WebTimerBase*&amp;gt;&amp;amp; timerHeap();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; const std::vector&amp;lt;WebTimerBase*&amp;gt;&amp;amp; timerHeap() const;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void start(double nextFireInterval, double repeatInterval);&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void startRepeating(double repeatInterval) { start(repeatInterval, repeatInterval); }&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void startOneShot(double interval) { start(interval, 0); }&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void stop();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; bool isActive() const;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; double nextFireInterval() const;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; double repeatInterval() const { return m_repeatInterval; }&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void augmentFireInterval(double delta) { setNextFireTime(m_nextFireTime + delta, nullptr); }&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void augmentRepeatInterval(double delta) { augmentFireInterval(delta); m_repeatInterval += delta; }&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; static void fireTimersInNestedEventLoop();&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; virtual void fired();&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void ref();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void deref();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; int refCount() const;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; const blink::WebTraceLocation&amp;amp; getTraceLocation()&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; {&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return m_location;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; }&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; const blink::WebThread::Task* getTask() const&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; {&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return m_task;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; }&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;private:&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; WebTimerBase(WebThreadImpl* threadTimers, const blink::WebTraceLocation&amp;amp; location, blink::WebThread::Task* task, int priority);&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void startFromOtherThread(double interval, double* createTimeOnOtherThread, unsigned* heapInsertionOrder);&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void checkConsistency() const;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void checkHeapIndex() const;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void setNextFireTime(double, unsigned* heapInsertionOrder);&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; bool inHeap() const { return m_heapIndex != -1; }&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void heapDecreaseKey();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void heapDelete();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void heapDeleteMin();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void heapIncreaseKey();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void heapInsert();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void heapPop();&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void heapPopMin();&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; void deleteLastOne();&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; WebThreadImpl* m_threadTimers;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; double m_nextFireTime; // 0 if inactive&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; double m_repeatInterval; // 0 if not repeating&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; int m_heapIndex; // -1 if not in heap&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; unsigned m_heapInsertionOrder; // Used to keep order among equal-fire-time timers&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;#ifndef NDEBUG&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; ThreadIdentifier m_thread;&lt;/div&gt;&lt;div&gt;#endif&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; friend class TimerHeapElement;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; friend class WebThreadImpl;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; friend bool operator&amp;lt;(const TimerHeapElement&amp;amp;, const TimerHeapElement&amp;amp;);&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; blink::WebTraceLocation m_location;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; blink::WebThread::Task* m_task;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; int m_ref;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; int m_priority;&lt;/div&gt;&lt;div&gt;};&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;align=left;" vertex="1" parent="1">
          <mxGeometry x="-800" y="-1520" width="830" height="1280" as="geometry" />
        </mxCell>
        <mxCell id="591SITI4Ghsz0lOfu50e-5" value="" style="endArrow=none;html=1;rounded=0;exitX=0.996;exitY=0.469;exitDx=0;exitDy=0;exitPerimeter=0;" edge="1" parent="1" source="591SITI4Ghsz0lOfu50e-4">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="70" y="-870" as="sourcePoint" />
            <mxPoint x="120" y="-920" as="targetPoint" />
          </mxGeometry>
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
